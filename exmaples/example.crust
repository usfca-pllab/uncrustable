// Accept binary numbers divisible by 3
alphabet: {0, 1}

// TODO Mod type in the type system
fn to_trit(digit: symbol) -> int[3] = match digit {
  '0' -> 0,
  '1' -> 1,
}

let remainder: int[3];

remainder = 0;

on input b {
  remainder = 2 * remainder + to_trit(b)
}

accept if remainder == 0

/*
For example:

For input "110" (which is 6 in decimal):
Start with remainder = 0
Process '1': remainder = 2 * 0 + to_trit(1)- > 1: (1 % 3) = 1
Process '1': remainder = 2 * 1 + to_trit(1)-> 3: (3 % 3) = 0
Process '0': remainder = 2 * 0 + to_trit(0)-> 0: (0 % 3) = 0
Final remainder is 0, so the number is divisible by 3 (6 รท 3 = 2)

For input "101" (which is 5 in decimal):
Start with remainder = 0
Process '1': remainder = 2 * 0 + to_trit(1)- > 1: (1 % 3) = 1
Process '0': remainder = 2 * 1 + to_trit(0)- > 0: (2 % 3) = 2
Process '1': remainder = 2 * 2 + to_trit(1)- > 1: (5 % 3) = 2
Final remainder is 2, so the number is not divisible by 3 (5 รท 3 = 1 with remainder 2)
*/